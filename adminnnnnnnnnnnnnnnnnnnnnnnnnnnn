import os
from typing import List, Optional, Any
from datetime import datetime, timedelta
import hashlib
import json
# FastAPI Imports
from fastapi import FastAPI, HTTPException, Depends, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from fastapi.middleware.cors import CORSMiddleware
# Pydantic Imports
from pydantic import BaseModel
# SQLAlchemy Imports
from sqlalchemy import create_engine, Column, Integer, String, Boolean, DateTime, ForeignKey, Text, JSON
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session, relationship
# ============================================================================
# 1. DATABASE CONFIGURATION
# ============================================================================
# For testing, we use SQLite. For production, switch to PostgreSQL:
# SQLALCHEMY_DATABASE_URL = "postgresql://user:password@localhost/dbname"
SQLALCHEMY_DATABASE_URL = "sqlite:///./sbi_test_platform.db"
engine = create_engine(
    SQLALCHEMY_DATABASE_URL, 
    connect_args={"check_same_thread": False} if "sqlite" in SQLALCHEMY_DATABASE_URL else {}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()
# Dependency to get DB session
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
# ============================================================================
# 2. SQLALCHEMY MODELS
# ============================================================================
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    first_name = Column(String, nullable=False)
    last_name = Column(String, nullable=False)
    department_code = Column(Integer, nullable=False)
    role = Column(String, default="user")  # 'admin' or 'user'
    is_locked = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    created_by = Column(String, default="system")
    last_login = Column(DateTime, nullable=True)
    # Relationships
    activity_logs = relationship("ActivityLog", back_populates="user")
class ActivityLog(Base):
    __tablename__ = "activity_logs"
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, ForeignKey("users.username"))
    action = Column(String, nullable=False)
    details = Column(JSON, nullable=True)
    timestamp = Column(DateTime, default=datetime.utcnow)
    status = Column(String, default="success")
    # Relationships
    user = relationship("User", back_populates="activity_logs")
# ============================================================================
# 3. PYDANTIC SCHEMAS
# ============================================================================
class Token(BaseModel):
    access_token: str
    token_type: str
class UserBase(BaseModel):
    username: str
    firstName: str
    lastName: str
    departmentCode: int
class UserCreate(UserBase):
    password: str
class UserResponse(UserBase):
    role: str
    isLocked: bool
    createdAt: Optional[datetime] = None
    lastLogin: Optional[datetime] = None
    class Config:
        from_attributes = True
class ActivityLogResponse(BaseModel):
    id: int
    username: str
    action: str
    details: Optional[Any] = None
    timestamp: datetime
    status: str
    class Config:
        from_attributes = True
# ============================================================================
# 4. APP SETUP & SECURITY
# ============================================================================
app = FastAPI(title="SBI Test Data Platform - Admin Enabled")
# CORS Setup
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
# Constants
SECRET_KEY = "your-secret-key-here"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
# Create Database Tables (Auto-migration for testing)
Base.metadata.create_all(bind=engine)
# ============================================================================
# 5. HELPER FUNCTIONS
# ============================================================================
def get_password_hash(password: str) -> str:
    return hashlib.sha256(password.encode()).hexdigest()
def verify_password(plain_password: str, hashed_password: str) -> bool:
    return get_password_hash(plain_password) == hashed_password
from jose import jwt, JWTError
def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
def log_user_activity(db: Session, username: str, action: str, details: dict, status: str = "success"):
    """Log user activity to database"""
    try:
        db_log = ActivityLog(
            username=username,
            action=action,
            details=details,
            status=status,
            timestamp=datetime.utcnow()
        )
        db.add(db_log)
        db.commit()
    except Exception as e:
        print(f"Failed to log activity: {e}")
# ============================================================================
# 6. DEPENDENCIES
# ============================================================================
async def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    
    user = db.query(User).filter(User.username == username).first()
    if user is None:
        raise credentials_exception
    return user
async def require_admin(current_user: User = Depends(get_current_user)):
    if current_user.role != "admin":
        raise HTTPException(
            status_code=403, 
            detail="Admin access required"
        )
    return current_user
# ============================================================================
# 7. AUTH ROUTES
# ============================================================================
@app.post("/token", response_model=Token)
async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    user = db.query(User).filter(User.username == form_data.username).first()
    
    # Check if user exists and password matches
    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    if user.is_locked:
        raise HTTPException(status_code=403, detail="Account is locked")
    # Update last login
    user.last_login = datetime.utcnow()
    db.commit()
    access_token = create_access_token(
        data={"sub": user.username, "role": user.role}
    )
    return {"access_token": access_token, "token_type": "bearer"}
@app.post("/setup-admin")
def create_initial_admin(db: Session = Depends(get_db)):
    """Helper to create the first admin user"""
    if db.query(User).filter(User.username == "admin").first():
        return {"message": "Admin already exists"}
    
    admin_user = User(
        username="admin",
        hashed_password=get_password_hash("admin123"),
        first_name="System",
        last_name="Admin",
        department_code=0,
        role="admin"
    )
    db.add(admin_user)
    db.commit()
    return {"message": "Admin user created (password: admin123)"}
# ============================================================================
# 8. ADMIN PANEL ROUTES
# ============================================================================
@app.get("/admin/users", response_model=List[UserResponse])
def admin_list_users(
    db: Session = Depends(get_db), 
    current_user: User = Depends(require_admin)
):
    users = db.query(User).all()
    return users
@app.post("/admin/users/{username}/lock")
def admin_lock_user(
    username: str, 
    db: Session = Depends(get_db), 
    current_user: User = Depends(require_admin)
):
    user = db.query(User).filter(User.username == username).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    if user.username == "admin":
        raise HTTPException(status_code=400, detail="Cannot lock main admin account")
    
    user.is_locked = True
    db.commit()
    log_user_activity(db, current_user.username, "lock_user", {"target_user": username})
    return {"message": f"User {username} locked"}
@app.post("/admin/users/{username}/unlock")
def admin_unlock_user(
    username: str, 
    db: Session = Depends(get_db), 
    current_user: User = Depends(require_admin)
):
    user = db.query(User).filter(User.username == username).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
        
    user.is_locked = False
    db.commit()
    log_user_activity(db, current_user.username, "unlock_user", {"target_user": username})
    return {"message": f"User {username} unlocked"}
@app.post("/admin/users/{username}/promote")
def admin_promote_user(
    username: str, 
    db: Session = Depends(get_db), 
    current_user: User = Depends(require_admin)
):
    user = db.query(User).filter(User.username == username).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    user.role = "admin"
    db.commit()
    log_user_activity(db, current_user.username, "promote_user", {"target_user": username})
    return {"message": f"User {username} promoted to admin"}
@app.delete("/admin/users/{username}")
def admin_delete_user(
    username: str, 
    db: Session = Depends(get_db), 
    current_user: User = Depends(require_admin)
):
    user = db.query(User).filter(User.username == username).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    if user.username == "admin" or user.username == current_user.username:
        raise HTTPException(status_code=400, detail="Cannot delete admin or yourself")
        
    db.delete(user)
    db.commit()
    log_user_activity(db, current_user.username, "delete_user", {"target_user": username})
    return {"message": f"User {username} deleted"}
@app.get("/admin/activities", response_model=List[ActivityLogResponse])
def admin_list_activities(
    db: Session = Depends(get_db), 
    current_user: User = Depends(require_admin)
):
    logs = db.query(ActivityLog).order_by(ActivityLog.timestamp.desc()).limit(100).all()
    return logs
@app.get("/admin/dashboard/stats")
def admin_dashboard_stats(
    db: Session = Depends(get_db), 
    current_user: User = Depends(require_admin)
):
    total_users = db.query(User).count()
    locked_users = db.query(User).filter(User.is_locked == True).count()
    active_users = total_users - locked_users
    total_activities = db.query(ActivityLog).count()
    
    yesterday = datetime.utcnow() - timedelta(hours=24)
    recent_activities = db.query(ActivityLog).filter(ActivityLog.timestamp > yesterday).count()
    
    return {
        "totalUsers": total_users,
        "activeUsers": active_users,
        "lockedUsers": locked_users,
        "totalActivities": total_activities,
        "recentActivities": recent_activities
    }
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000)
